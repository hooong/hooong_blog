[{"categories":null,"content":"django middleware에 대한 간략한 정리","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"개요 저는 django로 들어오는 request에서 필요한 정보들을 뽑아내고 해당 정보를 로그로 남길 필요성이 생겨 django middleware를 활용해보게 되었고, 이 과정을 통해 알게된 소소한 MIDDLEWARE에 대한 히스토리(?)를 이번 글을 통해 정리해보고자 합니다. ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:1:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"MIDDLEWARE란? MIDDLEWARE란 Django의 요청/응답 처리에 대한 후크 프레임워크입니다. 다시말해 Django로 들어오는 요청을 가로채 특정 작업을 하고 view로 보낸다거나 반대로 view를 거쳐 생성된 응답을 가로채 특정 작업을 한 뒤 클라이언트에게 보낼 수 있게 됩니다. ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:2:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"MIDDLEWARE는 어떻게 사용할까? Django의 MIDDLEWARE는 settings.py에서 사용할 미들웨어 클래스를 설정할 수 있습니다. MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 위와 같이 설정된 미들웨어는 정의된 순서에 따라 요청 시에는 위에서부터 응답 시에는 아래에서부터 차례대로 진행됩니다. 레퍼런스 문서를 보면 이와 같은 특징으로 미들웨어를 양파 껍질에 비유를 하고있었습니다. ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:3:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"Custom Middleware 구현 Django 프로젝트를 만들면 기본적으로 생성되는 미들웨어 이외의 커스텀한 클래스가 필요하다면 아래와 같이 미들웨어 클래스를 만들어 설정만 해준다면 얼마든지 사용이 가능합니다. class SimpleMiddleware: def __init__(self, get_response): self.get_response = get_response def __call__(self, request): # view 또는 하위 미들웨어가 호출되기 전 실행이 되는 부분 response = self.get_response(request) # view 또는 하위 미들웨어를 거친 뒤 실행이 되는 부분 return response SimpleMiddleware 클래스는 __init__() 메서드가 동작하는 과정에서 self.get_response 에 다음 단계의 미들웨어 혹은 실행될 view에 대한 정보가 담기게 됩니다. 또한, 실제로 __call__() 메서드의 동작을 통해 미들웨어가 동작하게 됩니다. MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'SimpleMiddleware', ] 예를들어 위와 같이 미들웨어가 설정되어있다면 SimpleMiddleware 의 동작을 간단히 살펴보면 다음과 같습니다. django.middleware.clickjacking.XFrameOptionsMiddleware 내부의 get_response를 통해 SimpleMiddleware가 실행되며, SimpleMiddleware의 get_response에는 실행될 view에 대한 정보가 담겨 실제로 view의 동작을 마친 뒤 생성된 response를 django.middleware.clickjacking.XFrameOptionsMiddleware로 반환하게 되며 SimpleMiddleware의 동작은 끝나게됩니다. ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:4:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"MIDDLEWARE_CLASSES는 뭐고? MIDDLEWARE와의 차이점은? MIDDLEWARE_CLASSES는 Django 1.10 이전에 MIDDLEWARE가 생겨나기 전에 사용되던 미들웨어를 지정하는 옵션으로 MIDDLEWARE와 동작에서 차이점이 존재하는데 이는 아래와 같습니다. MIDDLEWARE_CLASSES의 경우, self.get_response가 실행되기 전에 반환할 response가 존재하게 된다면 get_response가 실행되지 않고 해당 response를 반환해버리게 됩니다. process_exception()이 MIDDLEWARE_CLASSES의 경우에는 get_response()이전에 실행되는 process_request()에서 발생하는 예외에 대해서만 적용이 되는 반면, MIDDLEWARE는 view에서 발생하는 예외에 대해서만 적용이 됩니다. MIDDLEWARE_CLASSES에서 get_response()가 실행된 후 동작하는 process_response()에서 예외가 발생하는 경우에는 이후 과정을 모두 생략하고 500 에러를 바로 뱉는 반면, MIDDLEWARE는 예외가 발생하는 즉시 적절한 HTTP Response로 변환한 뒤에 반환해서 이후 과정을 생략하지 않고 처리하게 됩니다. ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:5:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"호환성을 위해서라면? MiddlewareMixin을 사용 MIDDLEWARE_CLASSES와 MIDDLEWARE 모두 호환을 시키기 위해서는 MiddlewareMixin을 상속받아 process_request(), process_response()를 정의해주면 됩니다. class TestMiddleware(MiddlewareMixin): def process_request(self, request): # get_response 실행 이전에 실행되는 코드 def process_response(self, request, response): # get_response 실행 이후에 실행되는 코드 return response MiddlewareMixin의 __call__ 메서드를 살펴보면 아래와 같아 동작을 이해하는데 도움이 됩니다. def __call__(self, request): # Exit out to async mode, if needed if asyncio.iscoroutinefunction(self.get_response): return self.__acall__(request) response = None if hasattr(self, 'process_request'): response = self.process_request(request) # process_request()에서 response가 있다면 get_response()는 실행되지 않는다. response = response or self.get_response(request) if hasattr(self, 'process_response'): response = self.process_response(request, response) return response ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:6:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"참고문서 Middleware | Django documentation | Django Settings | Django documentation | Django ","date":"2021-09-08","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/:7:0","tags":["Django"],"title":"[Django] MIDDLEWARE 와 MIDDLEWARE_CLASSES에 대한 정리","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95-copy/"},{"categories":null,"content":"macOS의 Docker Container에서 host로 접근하는 방법에 대한 정리","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"개요 SSH Tunneling을 통해 특정 애플리케이션에 접근해야하는 경우가 있을 수 있다. 예를들어, VPC 내부에서만 접근할 수 있는 RDS가 있다고 한다면 호스트에서 바로 RDS로 접근은 불가능하다. RDS에 접근하는 방법으로는 VPC 내부에 있는 EC2(외부에서 접속이 가능한)를 통해서 접근하는 방법이 있다. 이를 SSH Tunneling으로 특정 포트를 포워딩 시켜둔다면 호스트에서는 localhost:{특정 포트}를 사용해 RDS를 접근할 수 있게 된다. 위의 예시 상황에서 RDS에 접근해야하는 곳이 로컬(macOS)가 아닌 로컬에서 실행중인 도커 컨테이너이라고 가정해보자. 만약 network의 세팅값을 특별히 지정하지 않았다면 도커 컨네이너에서 localhost:{특정 포트}를 사용해 RDS를 접근할 수 없을 것이다. 필자는 이러한 상황에 부딛혀 도커 컨테이너에서 로컬(macOS) 호스트로 접근하는 방법에 대해 찾아보게 되었으며 그에 대한 내용을 정리해보고자 한다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:1:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"두 가지 방법에 대하여.. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. host 네트워크 드라이버 사용 docker는 여러가지의 network 방식을 제공하는데 bridge와 host에 대해 간단히 정리해보면 다음과 같다. bridge network docker0이라는 bridge(172.17.0.1)가 생성되고 컨테이너들이 이 docker0 으로 연결이 되고 이를 통해 외부 또는 내부 컨테이너간의 접근이 가능하다. Host 네트워크와 별개의 독립적인 네트워크를 구성할 수 있다. host network 컨테이너들이 독립적인 네트워크 영역을 갖지 않고 host(macOS)의 네트워크를 같이 사용한다. --net=host 옵션으로 지정할 수 있다. 위에서 두 가지 네트워크 방식을 살펴보았는데 ‘개요’에서 해결하고자 한 문제는 host 네트워크 방식을 사용한다면 localhost:{특정 포트} 를 통해 접속이 가능하게 된다. 하지만 도커 컨테이너 네트워크 영역을 가질 수 없다는 단점이 있다. 또!! 큰 단점이 하나가 더 있다. 바로 이 Host 네트워크 모드는 mac에서는 동작하지 않는다는 것이다. 결론적으로 macOS에서 컨테이너 내부에서 로컬(macOS) 호스트로 접근하기 위해서는 2번 방법을 사용해야한다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:1","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. host.docker.internal 도메인 사용 Docker는 자체적으로 host.docker.internal라는 도메인 네임을 가상으로 제공해준다. 이 도메인 네임을 이용하면 로컬(macOS) 호스트 영역으로 접근을 할 수 있다. 이를 사용한 예를 간단히 보이면 아래와 같다. 로컬 호스트에서 SSH Tunneling을 위해 20000번 포트로 포트포워딩을 해둔 상태라면 도커 컨테이너에서 host.docker.internal:20000 을 통해 RDS로 접속이 가능해진다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:2","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"결론 이번 글에서는 macOS의 도커 컨테이너 내부에서 로컬(macOS) 호스트로 접근하는 방법에 대하여 알아본 내용을 정리해보았다. 리눅스 머신을 사용한다면 host 네트워크 방식을 사용할 수 있겠지만 macOS에서는 이 host 네트워크 방식이 동작하지 않는다는 점이 있고 독립적인 네트워크를 사용할 수 없다는 단점을 가지고 있었다. 따라서 개요에서와 같은 문제에 부딛혔던 필자는 도커가 제공하는 host.docker.internal이라는 도메인 네임을 이용하므로써 의외로 간단하게 문제를 해결할 수 있었다. 이와 같은 경우가 빈번하지는 않을 것 같지만 해당 내용을 알고 있다면 필요한 상황에서는 꽤 유용하게 사용될 수 있을 것 같다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:3:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"참고 https://seorenn.tistory.com/20 https://bluese05.tistory.com/38 https://docs.mirantis.com/containers/v3.1/dockeree-ref-arch/networking/scalable-container-networks.html ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:4:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"입력된 순서를 보장하는 딕셔너리에 대한 정리","date":"2021-05-12","objectID":"/python_dictionary_order/","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"딕셔너리에 구현되어 있는 함수들 중 pop()과 popitem()이 있는 것을 보고 “딕셔너리에는 순서가 없는 것으로 알고있었는데 어떻게 큐에서나 사용되는 pop()이 구현될 수 있지?“라는 의문으로 찾아보게 되었던 결과를 글로 옮겨 적어보게 되었습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:0:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"딕셔너리란? 딕셔너리는 사전이라는 의미를 가지는 단어로 Python에서는 사전형 데이터를 담는 자료형을 뜻합니다. 사전형 데이터란 다른 말로 연관 배열이라고도 할 수 있습니다. 연관 배열은 키 하나와 값 하나가 연관되어 키를 통해 연관된 값을 얻을 수 있습니다. 실제로 국어사전을 통해 원하는 단어를 찾아 그에 연관된 단어의 뜻을 찾아보는 것을 생각해보면 쉽게 이해할 수 있습니다. 앞서 말한대로 딕셔너리는 하나의 키와 하나의 값을 가지며 {key: value} 형식으로 저장됩니다. # 딕셔너리 예시 people = {'name': '홍길동', 'age': 20} people['name'] \u003e '홍길동' people['age'] \u003e 20 키는 해시가 가능한 값으로 해시된 키를 이용해 값과 매핑하여 연관된 값을 저장하거나 얻어올 수 있습니다. 따라서 리스트, 딕셔너리와 같이 mutable한 객체는 해시가 불가능하여 딕셔너리의 키로는 사용할 수 없습니다. 또한, 리스트나 튜플처럼 순차적으로 값에 접근하는 것과 달리 딕셔너리는 해시된 키를 통해 바로 값에 접근이 가능하므로 입력된 순서를 저장할 필요성이 없었으며 실제로 Python3.5까지는 딕셔너리는 입력 순서를 저장하지 않습니다. 하지만 Python3.6부터는 딕셔너리를 구현하는 내부구조의 변경으로 인해 입력 순서를 저장하게 됩니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:1:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"Python3.6부터는 딕셔너리가 어떻게 순서를 저장하는가? 우선 아래의 예시를 통해 Python3.5와 Python3.6에서 딕셔너리가 입력된 순서를 저장하는지부터 확인해보겠습니다. # [Python3.5] 입력된 순서가 보장되지 않음. \u003e\u003e\u003e dict_3_5 = {} \u003e\u003e\u003e dict_3_5['a'] = 1 \u003e\u003e\u003e ddict_3_5['b'] = 2 \u003e\u003e\u003e dict_3_5['c'] = 3 \u003e\u003e\u003e dict_3_5 {'b': 2, 'a': 1, 'c': 3} # [Python3.6] 입력된 순서가 보장됨. \u003e\u003e\u003e dict_3_6 = {} \u003e\u003e\u003e dict_3_6['a'] = 1 \u003e\u003e\u003e dict_3_6['b'] = 2 \u003e\u003e\u003e dict_3_6['c'] = 3 \u003e\u003e\u003e dict_3_6 {'a': 1, 'b': 2, 'c': 3} 살펴본 바와 같이 Python3.6에서 딕셔너리가 어떻게 순서를 저장하는지를 알기 위해서는 Python3.6 이전과 이후의 딕셔너리 내부 구조에 대하여 살펴볼 필요가 있습니다. people = { 'firstname': '길동', 'lastname': '홍', 'job': '개발자' } 위 처럼 people이라는 딕셔너리 객체가 있을 때, Python3.6이전과 이후의 구조를 살펴보면 다음과 같습니다. Python3.6 이전의 딕셔너리 구조 Python3.6 이전에는 dk_size크기(dk_size는 해시테이블의 크기로 여기서는 8이다.)만큼의 entries라는 해시 테이블을 생성하고 해싱된 key값에 해당하는 인덱스 위치로 엔트리가 저장됩니다. 따라서 hash('firstname') % 8을 통해 바로 엔트리에 접근이 가능합니다. 반면, Python3.6 이후부터는 dk_size크기의 indices라는 해시 테이블을 두고 해싱된 key값에 해당하는 위치에 entries에 삽입될 위치의 인덱스를 저장하고 엔트리가 삽입될때마다 entries 배열에 삽입된 순서대로 삽입이 되는 구조로 바뀌었습니다. 즉, 순서를 저장할 수 있게되었습니다. 따라서 hash('firstname') % 8의 결과값을 가지고 indices에서 entries에 접근할 수 있는 인덱스를 얻은 뒤 entries[0]으로 접근이 가능하게 됩니다. 참고로 Python 3.6에서부터 순서가 생기는 구조로 변경이 된 것 같은데 Python의 레퍼런스 문서에서는 Python 3.7부터 지원한다고 써있는거 보니 3.7부터 공식으로 지원을 하는 것 같습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:2:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"배열의 개수가 늘었는데 메모리의 사용량이 줄었다? Python3.6 버전으로 오면서 딕셔너리를 구현하기 위해 사용하는 배열이 하나에서 두 개로 늘어났는데 메모리가 줄었다고하면 의문을 가질수도 있습니다. 결론부터 말하자면, 해시 테이블로 사용하는 희소배열의 타입을 바꿔 빈 공간에 대한 메모리를 줄일 수 있게 됩니다. 좀 더 자세히 살펴보면 Python3.6 이전 버전에서는 사이즈가 dk_size인 PyDictKeyEntry 타입의 entries 해시 테이블을 사용합니다. 따라서, 배열의 빈 공간마저 PyDictKeyEntry만큼의 메모리를 차지하여 낭비하는 부분이 컸습니다. 그러나 변경된 Python3.6 이후 버전에서는 사이즈가 dk_size인 char타입의 indices라는 해시 테이블과 PyDictKeyEntry를 담는 entries는 필요할때마다 할당되어 추가되어 Python3.6 이전 버전보다는 메모리를 효율적으로 사용할 수 있다고합니다. 위의 people 딕셔너리 객체를 가지고 계산을 해보면 다음과 같습니다. Python3.6 이전 버전의 경우 8(dk_size) * 8 * 3로 192 Bytes를 차지하게 되는 반면, Python3.6 이후 버전의 경우에는 8(dk_size) * 1 + (8 * 3 * 3)로 80 Bytes를 차지는 것을 확인해 볼 수 있습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:3:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"OrderedDict란? 사실 Python에는 3.6버전 이전부터 입력된 순서를 보장하는 특수한 딕셔너리 자료형을 가지고 있습니다. 그것이 바로 OrderedDict입니다. OrderedDict는 앞에서 말한바와 같이 순서를 보장하는 딕셔너리로 아래 예제를 통해 순서가 보장된다는 것을 확인해 볼 수 있습니다. # 입력된 순서가 보장되는 OrderedDict \u003e\u003e\u003e odered_dict = OrderedDict() \u003e\u003e\u003e odered_dict['a'] = 1 \u003e\u003e\u003e odered_dict['b'] = 2 \u003e\u003e\u003e odered_dict['c'] = 3 \u003e\u003e\u003e odered_dict OrderedDict([('a', 1), ('b', 2), ('c', 3)]) Python 3.6이후부터는 기존 딕셔너리도 입력된 순서를 가지게 되어 OrderedDict와 크게 차이점이 없다고 생각을 할 수 있습니다. 하지만 동등성을 확인할 때에 OrderedDict는 순서까지도 동등한지를 확인하게 되어 더 엄격하게 동등성을 검증합니다. 입력 순서는 다르지만 내용이 같은 경우에 서로 비교하는 예시를 아래에서 살펴볼 수 있습니다. # 기본 딕셔너리 \u003e\u003e\u003e dict_a {'a': 'apple', 'b': 'banana', 'p': 'pineapple'} \u003e\u003e\u003e dict_b {'b': 'banana', 'a': 'apple', 'p': 'pineapple'} \u003e\u003e\u003e dict_a == dict_b True # OrderedDict \u003e\u003e\u003e ordered_a OrderedDict([('a', 'apple'), ('b', 'banana'), ('p', 'pineapple')]) \u003e\u003e\u003e ordered_b OrderedDict([('b', 'banana'), ('a', 'apple'), ('p', 'pineapple')]) \u003e\u003e\u003e ordered_a == ordered_b False 따라서 데이터의 입력된 순서가 아주 중요한 상황이나 하위 호환성을 고려해야하는 상황에서는 OrderedDict를 사용하여 순서를 보장하는 고려해보는 것이 좋을 것 같습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:4:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"결론 딕셔너리와 OrderedDict에 대해서 간단히 알아보고 Python 3.5와 3.6에서 딕셔너리의 구현되어 있는 구조를 알아보면서 딕셔너리에 입력 순서가 저장되는 이유에 대해서 알아보았습니다. Python 3.6이후부터 딕셔너리에 순서가 생기기는 했지만, OrderedDict 부분에서 살펴본대로 동등성을 비교하는 부분이 다르고 하위호환을 고려한다면 용도에 맞게 사용하는 것이 좋을 것 같습니다. 참고 사이트 https://docs.python.org/ko/3/library/stdtypes.html#dict https://docs.python.org/3/library/collections.html#collections.OrderedDict https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6/39980744#39980744 https://github.com/zpoint/CPython-Internals/blob/master/BasicObject/dict/dict.md https://kadensungbincho.tistory.com/23 ","date":"2021-05-12","objectID":"/python_dictionary_order/:5:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"Git의 switch와 restore","date":"2021-04-14","objectID":"/git_switchrestore/","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Git의 switch와 restore에 대하여… ","date":"2021-04-14","objectID":"/git_switchrestore/:0:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"개요 Git 2.23.0 버전 이하에서 checkout 명령어 아래 두 가지의 기능을 동시에 가진다. branch를 전환 working tree의 파일을 복원 이처럼 하나의 명령어가 다른 두 가지 이상의 기능을 동시에 가지게 되면 명시적이지 않을 수 있다. 따라서 Git은 2.23.0버전에서 이 두 가지의 기능을 별도의 명령어로 나누어서 좀 더 명령어를 명시적으로 사용할 수 있게끔 만들었다. * Two new commands \"git switch\" and \"git restore\" are introduced to split \"checking out a branch to work on advancing its history\" and \"checking out paths out of the index and/or a tree-ish to work on advancing the current history\" out of the single \"git checkout\" command. Git v2.23.0 Release Notes 참고로 현재 *Git(2.24.3)*버전 기준으로 $ git --help 로 지원하는 명령어를 살펴보면 checkout 을 찾아볼 수 없다. start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ","date":"2021-04-14","objectID":"/git_switchrestore/:1:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"switch switch 명령어는 기본적으로 기존에 branch를 이동할 때 사용하던 git checkout \u003cbranch\u003e 와 동일한 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git switch [\u003coption\u003e] [--no-guess] \u003cbranch\u003e $ git switch [\u003coption\u003e] --detach [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] (-c|-C) \u003cnew-brach\u003e [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] --orphan \u003cnew-branch\u003e ","date":"2021-04-14","objectID":"/git_switchrestore/:2:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # issue1이라는 branch를 생성하고 전환 $ git switch -c issue1 # master branch로 전환 $ git switch master # HEAD 이전 커밋의 상태로 이동 $ git switch --detach HEAD~ # 현재 master branch라면 master branch상태에서 issue1 branch가 새로 생성되고 전환 $ git switch switch -C issue1 ","date":"2021-04-14","objectID":"/git_switchrestore/:2:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 \u003cstart-point\u003e 특정 위치에서 branch를 따낸다. default로는 HEAD 이다. -c | --create \u003cnew-branch\u003e \u003cstart-point\u003e 의 위치에서 새로운 branch를 생성하고 전환한다. -C | --force-create \u003cnew-branch\u003e \u003cnew-branch\u003e 가 이미 존재한다면 reset된 상태의 branch를 생성하고 전환한다. --detach 특정 커밋으로 상태를 전환한다. (기존 커밋은 남아있는 상태) -m | --merge Three-way merge를 진행한 뒤 branch를 만들고 전환한다. --orphan 새로운 orphan branch를 생성한 뒤 전환한다. -t | --track -c 옵션과 함께 사용할 때, upstream으로 지정할 원격 저장소의 브랜치를 지정할 수 있다. -c가 없다면 원격 branch에서 새로운 branch를 따서 생성하고 전환한다. --no-track로 지정할 경우에는 upstream을 구성하지 않는다. --guess, --no-guess branch를 생성할 때 원격 저장소에 동일한 이름이 있다면 자동으로 upstream으로 지정하여 매칭한다. --guess가 default이고 --no-guess는 자동으로 매칭이 되지 않게끔 설정한다. 이외의 더 많은 옵션은 git-scm-switch에서 살펴볼 수 있다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"restore restore 명령어는 특정 working tree의 파일로 돌리는 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:3:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] \u003cpathspec\u003e... $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] --pathspec-from-file=\u003cfile\u003e [--pathspec-file-nul] $ git restore (-p|--patch) [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] [\u003cpathspec\u003e...] ","date":"2021-04-14","objectID":"/git_switchrestore/:3:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # 현재 디렉터리('.')를 HEAD의 working tree로 복원 $ git restore . # 현재 디렉터리('.')를 특정 커밋('943453b')의 working tree로 복원 $ git restore -s 943453b . # 현재 디렉터리('.')를 특정 branch(issue1)의 working tree로 복원 $ git restore -s issue1 . # 현재 디렉터리('.')를 HEAD~의 index를 복원 $ git restore -s HEAD~ -S . # 현재 디렉터리('.')를 특정 위치의 index와 working tree 모두 복원 $ git restore -s HEAD~ -SW . # 'test.txt'을 unstageing 상태로 복원 $ git restore --staged test.txt ","date":"2021-04-14","objectID":"/git_switchrestore/:3:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 -s \u003ctree\u003e | --source=\u003ctree\u003e 특정 \u003ctree\u003e(commit, branch) 위치를 지정한다. -S | --staged 특정 위치의 index만을 복원한다. -s 옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -W | --worktree 특정 위치의 working tree를 복원한다. -S 와 -W를 모두 지정하면 index와 working tree 모두 복원한다. -S와 동일하게 -s옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -p | --patch 대화 모드로 명령어를 실행한다. 이외의 더 많은 옵션은 git-scm-restore에서 살펴볼 수 있다. 마무리하며… Git의 --help에서도 checkout 명령어를 삭제한 것을 보니 switch와 restore의 사용을 권장하고 있다는 것을 알 수 있었고, 본인도 기존에 checkout 명령어를 사용하였기에 switch와 restore를 최대한 의식적으로 사용해보고 있는데 확실히 기능이 분리되어 명시적으로 사용할 수 있어 좋다고 느껴졌다. 이 글을 읽으시는 여러분들도 익숙한 checkout을 대신하여 switch와 restore를 사용해보는 것을 추천합니다! ","date":"2021-04-14","objectID":"/git_switchrestore/:3:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Python의 Property","date":"2021-04-05","objectID":"/python_property/","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python에서 prooperty에 대한 정리 ","date":"2021-04-05","objectID":"/python_property/:0:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Property 이 글은 파이썬 클린코드 책의 내용을 정리한 글입니다. 프로퍼티는 객체의 어떤 속성에 대한 접근을 제어하려는 경우 사용한다. 이렇게 하는게 또한 파이썬스러운 코드라고 한다. 프로퍼티는 자바에서의 접근메서드인 getter와 setter를 만드는 것과 같은 용도라고 할 수 있다. def is_valid_email(potentially_valid_email: str): return re.match(EMAIL_FORMAT, potentially_valid_email) is not None class User: def __init__(self, username): self.username = username self._email = None @property def email(self): return self._email @email.setter def email(self, new_email): if not is_valid_email(new_email): raise ValueError(f'유요한 이메일이 아니므로 {new_email}값을 사용할 수 없음') self._email = new_email @email.deleter def email(self): self._email = None # 사용 예시 \u003e hong = User('hong') \u003e hong.email = 'hong@test.kr' \u003e hong.email 'hong@test.kr' \u003e del hong.email \u003e hong.__dict__ {'username': 'hong', '_email': None} @property가 붙은 메서드는 private 속성인 email 값을 반환한다. @email.setter가 붙은 메서드는 email값을 검증한 뒤 업데이트한다. @email.deleter가 붙은 메서드는 email 속성을 None로 초기화한다. 프로퍼티를 사용하면 명령-쿼리 분리 원칙(command and query separation)을 따르기 위한 좋은 방법이다. 명령-쿼리 분리 원칙이란? 객체의 메서드가 무언가의 상태를 변경하는 커맨드이거나 무언가의 값을 반환하는 쿼리이거나 둘 중에 하나만 수행해야지 둘 다 동시에 수행하면 안된다는 것 즉, 프로퍼티를 명령-쿼리로 나누어보면 @property 데코레이터는 무언가에 응답하기 위한 쿼리이고, @\u003cproperty_name\u003e.setter, @\u003cproperty_name\u003e.deleter데코레이터는 무언가를 하기 위한 커맨드이다. 또한, 책에서 덧붙이는 팁은 메서드는 한 가지만 수행해야 한다. 작업을 처리한 다음 상태를 확인하려면 메서드를 분리해야 한다. 이다. 예를들어 if self.set_email(\"a@j.com\")처럼 코드를 사용하게 되면 이메일을 설정하려는 건지, 이미 이메일이 해당 값으로 설정되어 있는지 확인하려는지, 아니면 동시에 이메일 값을 설정하고 상태가 유효한지 체크하는 것인지를 구분하기 어렵기때문이다. ","date":"2021-04-05","objectID":"/python_property/:1:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"추가적인 프로퍼티 사용법 위의 프로퍼티는 데코레이터를 사용한 방법이고 아래는 property class를 직접적으로 사용한 예제이다. class property(fget=None, fset=None, fdel=None, doc=None) # Return a property attribute class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self7777777777, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") # property 객체 반환 \u003e C.x \u003cproperty object at 0x109119cc0\u003e # property doc \u003e C.x.__doc__ \"I'm the 'x' property.\" \u003e a = C() # setx \u003e a.x = 'haha' # getx \u003e a.x 'haha' # delx \u003e del a.x ","date":"2021-04-05","objectID":"/python_property/:2:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python의 _, __에 대한 설명","date":"2021-04-05","objectID":"/python_private/","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"Python에서 Private속성을 다루는 방법과 name mangling에 대한 정리 ","date":"2021-04-05","objectID":"/python_private/:0:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"_ python은 java에서의 private처럼 객체 내부에서만 접근할 수 있는 «비공개» 인스턴스 변수는 존재하지 않는다. 그러나 변수명 앞에 _를 붙이는 규약을 통해 공개적이지 않은 부분으로 취급하는 규약이 있다. 이는 규약일 뿐, 얼마든지 해당 변수에 접근과 변경이 가능하다. class Person: def __init__(self, name, age, weight): self.name = name self.age = age self._weight = weight \u003e\u003e\u003e harry = Person('harry', 25, 70) \u003e\u003e\u003e harry.name 'harry' # _weight 접근 가능 \u003e\u003e\u003e harry._weight 70 # _weihgt 변경 가능 \u003e\u003e\u003e harry._weight = 80 \u003e\u003e\u003e harry._weight 80 ","date":"2021-04-05","objectID":"/python_private/:1:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"__ 그런데 변수명 앞에 __를 붙이고 접근을 하면 AttributeError가 발생하는 것을 확인할 수 있다. class Person: self.name = name self.age = age self.__weight = weight \u003e\u003e\u003e poter = Person('poter', 17, 60) \u003e\u003e\u003e poter.__weight Traceback (most recent call last): File \"\u003cinput\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Person' object has no attribute '__weight' __를 붙여서 접근을 못하게끔하여 private한 변수로 만드는 것으로 생각할 수도 있다. 그러나 AttributeError는 해당 필드(__weight)가 존재하지 않는다는 에러이다. Python에서 이는 이름 뒤섞기(name mangling)이라는 것으로 _\u003cclass-name\u003e__\u003cattribute-name\u003e이라는 속성을 만든다. 따라서 위의 예제에서 __weight에 접근하기 위해서는 아래와 같이 접근할 수 있다. \u003e\u003e\u003e poter._Person__weight 60 # poter가 가진 인스턴스 변수 확인 \u003e\u003e\u003e poter.__dict__ {'name': 'poter', 'age': 17, '_Person__weight': 65} # 물론 변경도 가능하다. \u003e\u003e\u003e poter._Person__weight = 65 \u003e\u003e\u003e poter._Person__weight?ㅇ 65 이러한 기능은 서브 클래스에서 정의된 이름들과의 충돌을 피하고자 존재한다고 한다. 따라서 클래스 내부의 메서드 호출을 방해하지 않고 서브 클래스들이 메서드를 재정의할 수 있도록 하는데 도움을 준다고 한다. Python Doc ","date":"2021-04-05","objectID":"/python_private/:2:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리 하나의 맥북에서 다른 두 개의 깃헙 계정을 사용해 푸시를 하고 싶은 상황이 생겨 알아보니 ssh-key를 사용하면 가능하였다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:0:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. ssh-key 생성하기 $ cd ~/.ssh $ ssh-keygen -t rsa -C \"{github 계정 이메일}\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): {key 이름 지정} $ ls -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_work -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_work.pub -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_persnal -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_persnal.pub ~/.ssh 디렉토리로 이동 후 두 번째 명령어를 실행하고 {key 이름 지정} 부분에 원하는 key 이름을 입력해준다. (ex. id_rsa_work) 위의 과정을 필요한 계정만큼 반복한다. (여기서는 두 개를 예로 듦.) 끝이나면 id_rsa_work, id_rsa_work.pub, id_rsa_persnal, id_rsa_persnal.pub라는 이름의 파일들이 생성된 것을 확인한다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:1:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. ssh-agent에 ssh-key 등록 $ ssh-add -K ~/.ssh/id_rsa_work $ ssh-add -K ~/.ssh/id_rsa_persnal ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:2:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"3. GitHub에 공개키 등록 로컬에서 생성한 공개키를 복사한다. $ pbcopy \u003c ~/.ssh/id_rsa_work.pub github에 ssh-key에 해당하는 계정으로 로그인 github 계정의 settings - SSH and GPG keys 메뉴를 클릭한다. 3. `New SSH key`를 클릭 4. `title`에는 key에 대한 이름을 지정하고 `key`에 1번에서 복사한 내용을 붙여넣어 준다. 5. 필요한 계정만큼 반복해준다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:3:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"4. ssh config $ cd ~/.ssh $ vi config # 없다면 생성 # 아래 내용을 입력 Host github.com-work HostName github.com User work IdentityFile ~/.ssh/id_rsa_work Host github.com-persnal HostName github.com User persnal IdentityFile ~/.ssh/id_rsa_persanl Host : 저장소를 구분하는 일종의 key IdentityFile : ssh-key를 지정 ssh 테스트 해보기 $ ssh -T git@github.com-work Hi {GithubID}! You've successfully authenticated, but GitHub does not provide shell access. 아래 문구가 뜬다면 정상이다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:4:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"5. 특정 프로젝트의 git config $ vi {프로젝트}/.git/config ... [user] email = {푸시할 계정의 이메일} git의 global config가 설정되어있는 경우, 위와 같은 설정을 해주어야 해당 계정으로 푸시를 할 수 있음. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:5:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"6. remote 설정 github에서 git ssh로 clone을 받을 수 있다. : git@github.com-work:work/{프로젝트}.git 또는 이미 remote가 지정되어 있는 상태라면 아래 명령어를 통해 ssh로 바꿀 수 있다. $ git remote set-url origin git@{Host}:{User}/{프로젝트}.git ex. git remote set-url origin git@github.com-work:work/{프로젝트}.git 참고 https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent https://velog.io/@sonypark/GitHubSSH%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EA%B9%83%ED%97%88%EB%B8%8C-%EA%B3%84%EC%A0%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6mk3iesh0u ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:6:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리 훌륭한 코드는 그 자체로 (주석이 없어도) 자명하지만 문서화 또한 잘 되어있어야한다. 문서화라고해서 주석이 주렁주렁 달린 코드를 말하는 것이 아닌 문서화를 통해 데이터 타입이 무엇인지 설명하고 때에따라 예제를 제공하는 것을 목표로 한다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:0:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Docstring Docstring은 소스코드에 포함된 문서라고 말할 수 있으며, 기본적으로 리터럴 문자열로 구성되며 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치된다. 파이썬의 경우 동적 타이핑을 하기 때문에 함수의 입력과 출력을 문서화하여 사용자가 사용할 때 함수가 어떻게 동작하는지 이해하기 쉽게끔 docstring으로 문서화를 하는 것이 코드의 동작을 이해하는데 큰 도움이 될 수 있다. 따라서 Docstring을 아래와 같이 정리해 볼 수 있다. Docstring은 ‘이유’가 아닌 ‘설명’이다. 코드의 특정 컴포넌트(module, class, method, function)에 대한 문서화이다. 가능한 많은 docstring을 추가하는 것이 권장된다. Sphinx(스핑크스)를 실행하여 autodoc 익스텐션을 사용하면 자동으로 문서를 만들 수 있다. Example \u003e\u003e\u003e def my_function(): ... \"\"\" ... 1. 이 함수가 하는 일은 무엇인가요? ... ... 2. 이 함수는 무엇을 입력받나요? ... ... 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요? ... \"\"\" ... pass ... \u003e\u003e\u003e my_function.__doc__ '1. 이 함수가 하는 일은 무엇인가요?\\n \\n 2. 이 함수는 무엇을 입력받나요?\\n \\n 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요?\\n' \"\"\"{docstring}\"\"\" : 리터럴 문자열로 특정 컴포넌트에 대한 문서화를 작성 __doc__ : 해당 속성을 통해 docstring에 접근 가능 # dict.update에 대한 docstring 예제 \u003e\u003e\u003e dict.update.__doc__ 'D.update([E, ]**F) -\u003e None. Update D from dict/iterable E and F.\\n If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]\\n If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v\\n In either case, this is followed by: for k in F: D[k] = F[k]' ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:1:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation Python의 경우 동적으로 타입을 결정하기 때문에 함수나 메서드를 거치면서 변수나 객체의 값이 무엇인지 알기가 어려운 경우가 많으므로 어노테이션을 통해 이러한 정보를 명시해준다면 다른 개발자가 코드를 쉽게 이해하는데 도움이 된다. Java에도 Annotation이 존재한다. 그러나 Python에서의 Annotation은 단순히 타입에 대한 힌트를 주는 역할만을 하게된다. (Java의 Annotation은 Python의 Decorator가 비슷한 역할을 한다고 볼 수 있다.) Annotation에 대해 간단히 정리해보면 다음과 같다. 변수의 예상 타입을 지정하여 힌트를 줄 수 있다. (타입 뿐만 아니라 어떤 형태의 메타데이터라도 지정할 수 있다.) annotation정보를 사용하여 문서 생성, 유효성 검증, 타입 체크를 할 수 있다. Example \u003e\u003e\u003e class Point: ... def __init__(self, lat, long): ... self.lat = lat ... self.long = long ... \u003e\u003e\u003e def locate(latitude: float, longitude: float) -\u003e Point: ... \"\"\"맴에서 좌표에 해당하는 객체를 검색\"\"\" ... return Point(latitude, longitude) ... \u003e\u003e\u003e locate.__annotations__ {'latitude': \u003cclass 'float'\u003e, 'longitude': \u003cclass 'float'\u003e, 'return': \u003cclass '__main__.Point'\u003e} # 변수에도 지정 가능 (Python 3.6이상) \u003e\u003e\u003e class Point: ... lat: float ... long: float ... \u003e\u003e\u003e Point.__annotations__ {'lat': \u003cclass 'float'\u003e, 'long': \u003cclass 'float'\u003e} # 타입이 아닌 문자열도 가능 \u003e\u003e\u003e def aa() -\u003e \"리턴\": ... pass ... \u003e\u003e\u003e aa.__annotations__ {'return': '리턴'} : : 함수의 파라미터 및 변수 뒤에 콜론을 이용하여 annotation을 달 수 있다. -\u003e : 함수의 반환값에 대한 annotation을 달 수 있다. __annotations__ : 해당 속성을 통해 annotation에 접근 가능 ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:2:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation은 Docstring을 대체? Docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것은 사실이지만, docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 한다. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋다는 것이다. def data_from_response(response: dict) -\u003e dict: if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 예를들어 위와 같이 데이터의 유효성을 검사하고 dict값을 반환하는 함수를 보면 response객체의 올바른 인스턴스의 형태는 알 수가 없다. 따라서 아래와 같이 이러한 함수에 docstring을 통해 보다 나은 설명을 추가할 수가 있다. def data_from_response(response: dict) -\u003e dict: \"\"\"response에 문제가 없다면 response의 payload를 반환 - response의 예:: { \"status\": 200, # \u003cint\u003e \"payload\": { ... } # 반환하려는 데이터 } - 반환 dict 값의 예:: {\"data\": { ... } } - 발생 가능한 예외: - HTTP status가 200이 아닌 경우 ValueError 발생 \"\"\" if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 또한, docstring은 단위 테스테에서도 유용한 정보로 사용될 수 있다. 예를들어, 테스트용 입력 값을 생성할 수도 있고 테스트의 성공 실패를 판단하는 것이다. 간단히 정리를 해보자면, Annotation은 Docstring을 부분적으로 대체를 할 수는 있겠지만, Annotation과 Docstring을 적절히 사용하여 코드의 가독성을 높이고 코드에 대한 문서화를 더욱 보기 좋게 다듬는 것이 중요하다고 할 수 있겠다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:3:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"}]